# 🚀 BIST AI Smart Trader v5.0 - Master Implementation Plan

**Sürüm:** v5.0 "Enterprise Hedge Fund Intelligence"
**Mimari:** 3-Katmanlı (Data → Model → Presentation)
**Hedef:** Kurumsal yatırımcı seviyesinde platform

---

## 🏗️ **V5.0 MİMARİ ÖZET**

```
📡 DATA LAYER
 ├── 🔴 Real-time Feeds (BIST, Forex, News)
 ├── 🟡 Quality Monitor + Freshness
 └── 🟢 Anomaly Detection + Cross-validation

🧮 MODEL LAYER  
 ├── 🤖 AI Brain 2.0 (RL, Event-Aware, Multi-model)
 ├── 📊 Risk Engine (CVaR, Dynamic SL, Hedging)
 ├── 💎 Portfolio Optimizer (Markowitz, Risk Parity, Tax-aware)
 └── 🧪 Backtesting (Walk-forward, Monte Carlo)

📊 PRESENTATION LAYER
 ├── 🎯 AI Insights + XAI
 ├── 📈 Performance Metrics (Sharpe, p-value, R²)
 └── 📱 Mobile + Pro UI
```

---

## ⚡️ **1. RISK MANAGEMENT LAYER** (Sprint 1 - Yüksek Öncelik)

### 🎯 Hedef: CVaR + Dynamic Stop-Loss + Hedging

#### **CVaR (Conditional Value at Risk)**

**Konsept:**
"En kötü senaryoda %5 ihtimale göre max kayıp hesapla"

**Implementation:**
```python
# backend/services/risk_engine.py
import numpy as np
from scipy import stats

class RiskEngine:
    def calculate_cvar(self, portfolio, confidence=0.05):
        """
        CVaR hesaplama
        Örnek: %5 kuyrukta ortalama kayıp %8
        """
        returns = self.get_historical_returns(portfolio)
        
        # VAR hesapla (%5 percentile)
        var = np.percentile(returns, confidence * 100)
        
        # CVaR = VAR altındaki ortalamalar
        cvar = returns[returns <= var].mean()
        
        return {
            'cvar': cvar,
            'var': var,
            'max_loss_5pct': f"{cvar:.2f}%",
            'confidence': confidence
        }
    
    def portfolio_cvar_heatmap(self, portfolio):
        """
        Portföy bazlı CVaR heatmap
        Her hissenin risk katkısını renkli göster
        """
        heatmap_data = []
        
        for stock, weight in portfolio.items():
            stock_returns = self.get_stock_returns(stock)
            cvar = self.calculate_cvar_single(stock_returns)
            
            heatmap_data.append({
                'symbol': stock,
                'weight': weight,
                'cvar': cvar,
                'risk_contribution': weight * cvar,
                'color': self.get_risk_color(cvar)
            })
        
        return heatmap_data
```

**UI Entegrasyonu:**
```typescript
// web-app/src/components/RiskManagementPanel.tsx
export function RiskManagementPanel() {
  const cvar = useRiskEngine();
  
  return (
    <div className="risk-heatmap">
      <h3>📊 CVaR Heatmap (Portföy Risk Dağılımı)</h3>
      
      {/* Her hissenin risk katkısını renkli göster */}
      {cvar.heatmap.map(stock => (
        <div key={stock.symbol} 
             style={{ backgroundColor: stock.color }}>
          {stock.symbol}: %{stock.risk_contribution.toFixed(1)}
        </div>
      ))}
      
      <div className="risk-summary">
        🎯 Max kayıp riski (CVaR %5): {cvar.max_loss}
        ⚠️ Portföy ortalaması CVaR: {cvar.portfolio_cvar}
      </div>
    </div>
  );
}
```

---

#### **Dynamic Stop-Loss AI**

**Konsept:**
ATR (Average True Range) bazlı dinamik stop-loss + AI confidence skoru

**Implementation:**
```python
# backend/services/dynamic_stop_loss.py
import talib

class DynamicStopLoss:
    def calculate_atr_stop(self, df, period=14, multiplier=2.0):
        """
        ATR tabanlı dinamik stop-loss
        Volatilite arttıkça stop mesafesi uzar
        """
        high = df['High']
        low = df['Low']
        close = df['Close']
        
        atr = talib.ATR(high, low, close, timeperiod=period)
        current_price = close.iloc[-1]
        
        # Stop loss = ATR * multiplier altında
        stop_loss = current_price - (atr.iloc[-1] * multiplier)
        
        return stop_loss
    
    def confidence_adjusted_stop(self, stop_loss, ai_confidence):
        """
        AI sinyal güvenine göre stop esnekliği
        Yüksek confidence → tighter stop
        Düşük confidence → looser stop
        """
        if ai_confidence > 0.85:
            # Çok güvenilir → sıkı stop (%1)
            adjusted_stop = stop_loss * 0.99
        elif ai_confidence > 0.70:
            # Orta güven → normal stop (%2)
            adjusted_stop = stop_loss * 0.98
        else:
            # Düşük güven → gevşek stop (%3)
            adjusted_stop = stop_loss * 0.97
        
        return adjusted_stop
    
    def get_stop_recommendation(self, symbol, ai_confidence):
        """
        Ana fonksiyon: Stop-loss önerisi
        """
        df = self.fetch_price_data(symbol)
        atr_stop = self.calculate_atr_stop(df)
        adjusted_stop = self.confidence_adjusted_stop(atr_stop, ai_confidence)
        
        return {
            'symbol': symbol,
            'current_price': df['Close'].iloc[-1],
            'atr_stop': atr_stop,
            'adjusted_stop': adjusted_stop,
            'distance_pct': ((df['Close'].iloc[-1] - adjusted_stop) / df['Close'].iloc[-1]) * 100,
            'ai_confidence': ai_confidence,
            'risk_tier': self.get_risk_tier(adjusted_stop, df['Close'].iloc[-1])
        }
```

**UI Entegrasyonu:**
```typescript
// Sinyal tablosuna dinamik stop-loss ekle
<table>
  {signals.map(signal => (
    <tr>
      <td>{signal.symbol}</td>
      <td>{signal.price}</td>
      <td>🛑 Stop-Loss: {signal.dynamic_stop}</td>
      <td>
        <RiskBar 
          value={signal.stop_distance} 
          max={5}
        />
        {/* Yeşil: Güvenli, Kırmızı: Riskli */}
      </td>
    </tr>
  ))}
</table>
```

---

#### **Hedging Layer**

**Konsept:**
Portföyde pozitif korelasyona sahip aşırı exposure → otomatik hedge önerisi

**Implementation:**
```python
# backend/services/hedging.py
import numpy as np

class HedgingEngine:
    def detect_overexposure(self, portfolio, threshold=0.30):
        """
        Portföyde aşırı exposure tespit
        Örnek: Bankacılık sektöründe >%30
        """
        sector_exposures = self.calculate_sector_exposure(portfolio)
        
        overexposed = []
        for sector, exposure in sector_exposures.items():
            if exposure > threshold:
                overexposed.append({
                    'sector': sector,
                    'exposure': exposure,
                    'recommendation': self.suggest_hedge(sector)
                })
        
        return overexposed
    
    def suggest_hedge(self, sector):
        """
        Koruyucu pozisyon önerisi
        """
        hedges = {
            'bankacılık': {
                'instrument': 'BIST30 short',
                'ratio': 0.25,  # Portföyün %25'i hedge
                'reasoning': 'Bankacılıkta aşırı pozisyon riski'
            },
            'sanayi': {
                'instrument': 'USDTRY long',
                'ratio': 0.30,
                'reasoning': 'Sanayi sektörü USDTRYE duyarlı'
            }
        }
        
        return hedges.get(sector, None)
    
    def automatic_hedge_suggestion(self, portfolio):
        """
        AI tabanlı otomatik hedge önerisi
        """
        correlation_matrix = self.get_correlation_matrix(portfolio)
        
        # En yüksek korelasyona sahip pozisyonu bul
        max_corr_pos = self.find_max_correlation_position(correlation_matrix)
        
        # Hedge önerisi
        hedge = {
            'action': 'SHORT',
            'symbol': max_corr_pos['counter_symbol'],
            'size': f"{max_corr_pos['correlation'] * 100:.0f}% of portfolio",
            'reason': f"High correlation ({max_corr_pos['correlation']:.2f}) with {max_corr_pos['primary_symbol']}"
        }
        
        return hedge
```

**UI Entegrasyonu:**
```typescript
// Otomatik hedge öneri kartı
<div className="hedge-alert">
  <h4>🛡️ Portfolio Hedging Önerisi</h4>
  <p>Bankacılık sektöründe aşırı pozisyon tespit edildi</p>
  <div className="hedge-recommendation">
    Öneri: Portföyünüzün %25'ini BIST30 SHORT ile hedge edin
    <button>Otomatik Hedge Uygula</button>
  </div>
</div>
```

---

## 💎 **2. PORTFOLIO OPTIMIZATION ENGINE** (Sprint 1 - Yüksek Öncelik)

### 🎯 Hedef: Markowitz + Risk Parity + Tax-aware

#### **Mean-Variance Optimization (Markowitz)**

**Konsept:**
En yüksek Sharpe ratio için optimal ağırlıklar

**Implementation:**
```python
# backend/services/portfolio_optimizer.py
from scipy.optimize import minimize
import numpy as np

class PortfolioOptimizer:
    def __init__(self, expected_returns, cov_matrix):
        self.mu = expected_returns  # Beklenen getiriler
        self.S = cov_matrix         # Kovaryans matrisi
    
    def max_sharpe_ratio(self, risk_free_rate=0.10):
        """
        En yüksek Sharpe ratio için optimal ağırlıklar
        """
        def negative_sharpe(weights):
            portfolio_return = np.sum(self.mu * weights)
            portfolio_std = np.sqrt(np.dot(weights.T, np.dot(self.S, weights)))
            sharpe = (portfolio_return - risk_free_rate) / portfolio_std
            return -sharpe  # Negatif çünkü minimize ediyoruz
        
        n = len(self.mu)
        initial_weights = np.array([1/n] * n)
        bounds = tuple((0, 1) for _ in range(n))
        constraints = {'type': 'eq', 'fun': lambda w: np.sum(w) - 1}
        
        result = minimize(negative_sharpe, initial_weights,
                         method='SLSQP', bounds=bounds,
                         constraints=constraints)
        
        return {
            'weights': result.x,
            'expected_return': np.sum(self.mu * result.x),
            'volatility': np.sqrt(np.dot(result.x.T, np.dot(self.S, result.x))),
            'sharpe_ratio': -result.fun
        }
    
    def efficient_frontier(self, target_returns):
        """
        Efficient frontier çizimi için
        """
        frontier = []
        
        for target_ret in target_returns:
            def portfolio_variance(weights):
                return np.dot(weights.T, np.dot(self.S, weights))
            
            constraints = [
                {'type': 'eq', 'fun': lambda w: np.sum(w) - 1},
                {'type': 'eq', 'fun': lambda w: np.sum(self.mu * w) - target_ret}
            ]
            
            result = minimize(portfolio_variance, initial_weights,
                            method='SLSQP', bounds=bounds,
                            constraints=constraints)
            
            frontier.append({
                'return': target_ret,
                'risk': np.sqrt(result.fun),
                'weights': result.x
            })
        
        return frontier
```

**UI Entegrasyonu:**
```typescript
// Efficient Frontier grafiği
<ResponsiveContainer>
  <LineChart data={frontier}>
    <Line dataKey="risk" stroke="#8884d8" />
    <CartesianGrid />
    <XAxis dataKey="risk" label="Risk (Volatilite)" />
    <YAxis dataKey="return" label="Beklenen Getiri" />
  </LineChart>
</ResponsiveContainer>

{/* Kullanıcının portföyünü nokta ile göster */}
<Dot 
  cx={user_portfolio.risk} 
  cy={user_portfolio.return} 
  fill="#10b981"
/>
```

---

#### **Risk Parity Portfolio**

**Konsept:**
Her hissenin volatilitesinin tersine oranlı ağırlıklar

**Implementation:**
```python
def risk_parity_weights(returns):
    """
    Risk parity: Her hissenin risk katkısı eşit
    """
    volatilities = returns.std() * np.sqrt(252)  # Yıllık volatilite
    
    # Ağırlık = 1/volatilite (normalize)
    inv_vol = 1 / volatilities
    weights = inv_vol / inv_vol.sum()
    
    return weights

def adaptive_risk_parity(returns, forecasted_vol):
    """
    AI forecast edilmiş volatiliteye göre dinamik risk parity
    """
    # Güncellenmiş volatilite tahminleri
    updated_vol = forecasted_vol
    
    inv_vol = 1 / updated_vol
    weights = inv_vol / inv_vol.sum()
    
    return weights
```

---

#### **Tax-Aware Optimization**

**Konsept:**
Stopaj ve vergi sonrası net getiri hesabı

**Implementation:**
```python
def net_return_calculator(gross_return, holding_period_days, tax_rate=0.15):
    """
    Türkiye için stopaj hesaplama
    """
    if holding_period_days > 365:
        # Uzun vadeli (>1 yıl)
        tax = gross_return * tax_rate * 0.5  # Yarı vergi
    else:
        # Kısa vadeli (<1 yıl)
        tax = gross_return * tax_rate
    
    net_return = gross_return - tax
    return {
        'gross_return': gross_return,
        'tax_paid': tax,
        'net_return': net_return,
        'tax_efficiency': net_return / gross_return
    }

def tax_aware_portfolio(returns, tax_rates):
    """
    Vergi sonrası optimal portföy
    """
    # Net returns hesapla
    net_returns = {}
    for symbol, ret in returns.items():
        net_ret = net_return_calculator(ret, 90)  # 3 aylık
        net_returns[symbol] = net_ret['net_return']
    
    # Markowitz optimization ile yeniden hesapla
    optimal = optimize_with_net_returns(net_returns)
    
    return optimal
```

---

## 🧪 **3. BACKTESTING INFRASTRUCTURE** (Sprint 1 - Yüksek Öncelik)

### 🎯 Hedef: Walk-forward + Monte Carlo

#### **Walk-Forward Analysis**

**Konsept:**
Modeli overfitting'den koruyan validation yöntemi

**Implementation:**
```python
# backend/services/backtesting.py
def walk_forward_test(model, data, train_months=6, test_months=1, 
                       step_size=1):
    """
    Walk-forward test
    Model sürekli retrain + test olur
    """
    results = []
    
    n_windows = (len(data) - train_months - test_months) // step_size
    
    for i in range(n_windows):
        train_start = i * step_size
        train_end = train_start + train_months
        test_end = train_end + test_months
        
        train_data = data[train_start:train_end]
        test_data = data[train_end:test_end]
        
        # Train
        model.fit(train_data)
        
        # Test
        predictions = model.predict(test_data)
        actual = test_data['target']
        
        # Metrics
        pnl = calculate_pnl(predictions, actual, test_data)
        sharpe = calculate_sharpe(pnl)
        win_rate = calculate_win_rate(predictions, actual)
        
        results.append({
            'window': i,
            'train_period': f"{train_start}-{train_end}",
            'test_period': f"{train_end}-{test_end}",
            'pnl': pnl,
            'sharpe': sharpe,
            'win_rate': win_rate,
            'avg_return': np.mean(pnl),
            'max_drawdown': calculate_max_drawdown(pnl)
        })
    
    # Summary
    return {
        'individual_results': results,
        'average_sharpe': np.mean([r['sharpe'] for r in results]),
        'consistency_score': len([r for r in results if r['win_rate'] > 0.60]) / len(results),
        'best_window': max(results, key=lambda x: x['sharpe']),
        'worst_window': min(results, key=lambda x: x['sharpe'])
    }
```

**UI Entegrasyonu:**
```typescript
// Backtest sonuçlarını göster
<div className="backtest-results">
  <h3>🧪 Walk-Forward Test Sonuçları</h3>
  
  <div className="summary">
    <MetricCard 
      label="Ortalama Sharpe"
      value={results.average_sharpe}
      color="#10b981"
    />
    <MetricCard 
      label="Tutarlılık Skoru"
      value={`${results.consistency_score * 100}%`}
    />
  </div>
  
  {/* Her window'u line chart ile göster */}
  <LineChart data={results.individual_results}>
    <Line dataKey="sharpe" />
  </LineChart>
</div>
```

---

#### **Monte Carlo Simulation**

**Konsept:**
10,000 senaryo ile risk dağılımı

**Implementation:**
```python
def monte_carlo_simulation(strategy, portfolio, n_simulations=10000):
    """
    Monte Carlo: Random senaryolarla gelecek simülasyonu
    """
    results = []
    
    for _ in range(n_simulations):
        # Random walk simülasyonu
        simulated_returns = np.random.normal(
            mean_return, 
            volatility, 
            days=90
        )
        
        # Portfolio value hesapla
        portfolio_value = simulate_portfolio(portfolio, simulated_returns)
        
        results.append({
            'final_value': portfolio_value,
            'pnl': portfolio_value - initial_value,
            'pnl_pct': (portfolio_value - initial_value) / initial_value * 100
        })
    
    # İstatistikler
    return {
        'mean_pnl': np.mean([r['pnl_pct'] for r in results]),
        'median_pnl': np.median([r['pnl_pct'] for r in results]),
        'std_pnl': np.std([r['pnl_pct'] for r in results]),
        'cvar_5pct': np.percentile([r['pnl_pct'] for r in results], 5),
        'probability_profit': sum(1 for r in results if r['pnl'] > 0) / len(results),
        'all_scenarios': results
    }
```

**UI Entegrasyonu:**
```typescript
// Monte Carlo confidence distribution
<div className="monte-carlo">
  <h3>🧪 Monte Carlo Simülasyonu (10,000 Senaryo)</h3>
  
  <HistogramChart data={mc_results.all_scenarios}>
    {/* Kâr/zarar dağılımı histogram */}
  </HistogramChart>
  
  <div className="confidence-bands">
    {/* %95 güven aralığı göster */}
    <div className="band-95">
      %95 Güven Aralığı: [{mc_results.cvar_5pct}% - {mc_results.median_pnl}%]
    </div>
  </div>
  
  <MetricCard 
    label="Kâr Olasılığı"
    value={`${mc_results.probability_profit * 100}%`}
    color="#10b981"
  />
</div>
```

---

## 📊 **MİMARİ GÖRÜNÜM - V5.0+**

```
┌─────────────────────────────────────────────────┐
│        BIST AI Smart Trader v5.0                │
│         "Enterprise Intelligence"                │
└─────────────────────────────────────────────────┘

📡 DATA LAYER
├─ Real-time Feeds (yfinance, Finnhub, NewsAPI)
├─ Quality Monitor (Freshness, Anomaly, Cross-validation)
└─ Cache Layer (Redis)

🧮 MODEL LAYER
├─ AI Brain 2.0
│  ├─ Reinforcement Learning Engine
│  ├─ Event-Aware Model
│  └─ Multi-model Ensemble (LightGBM + LSTM + TimeGPT)
│
├─ Risk Engine
│  ├─ CVaR Calculator
│  ├─ Dynamic Stop-Loss AI
│  └─ Hedging Engine
│
├─ Portfolio Optimizer
│  ├─ Markowitz (Max Sharpe)
│  ├─ Risk Parity
│  └─ Tax-Aware Optimization
│
└─ Backtesting Engine
   ├─ Walk-Forward Validator
   └─ Monte Carlo Simulator

📊 PRESENTATION LAYER
├─ Dashboard (Metrics, Signals, Charts)
├─ Risk Heatmap (CVaR)
├─ Portfolio Optimizer UI
├─ Backtest Results Viewer
└─ Mobile Lite View
```

---

## 🎯 **İMPLEMENTASYON ÖNCELİĞİ**

| Sprint | Özellikler | Süre | Bağımlılık |
|--------|-----------|------|-----------|
| **Sprint 1** | Risk Engine + Portfolio Optimizer | 2 hafta | Backend API |
| **Sprint 2** | Backtesting Infrastructure | 2 hafta | Risk Engine |
| **Sprint 3** | UI Integration + Multi-timeframe | 2 hafta | Tüm backend |

**Toplam:** 6 hafta

---

## 💰 **HEDEF PAZAR v5.0**

- ✅ Private investors (Pro tier)
- ✅ Family offices
- ✅ Wealth management firms
- ✅ Kurumsal yatırımcılar
- ✅ Yatırım danışmanları

---

**Çağlar, bu roadmap ile BIST AI Smart Trader gerçekten "hedge fund seviyesinde" bir platform olur. 🚀**

